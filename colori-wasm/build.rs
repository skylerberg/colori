use colori_core::cards::*;
use colori_core::types::*;
use std::fmt::Write as FmtWrite;
use std::io::Write;

fn format_ability(ability: &Ability) -> String {
    match ability {
        Ability::Workshop { count } => format!("{{ type: 'workshop', count: {} }}", count),
        Ability::DrawCards { count } => format!("{{ type: 'drawCards', count: {} }}", count),
        Ability::MixColors { count } => format!("{{ type: 'mixColors', count: {} }}", count),
        Ability::DestroyCards => "{ type: 'destroyCards' }".to_string(),
        Ability::Sell => "{ type: 'sell' }".to_string(),
        Ability::GainDucats { count } => format!("{{ type: 'gainDucats', count: {} }}", count),
        Ability::GainSecondary => "{ type: 'gainSecondary' }".to_string(),
        Ability::GainPrimary => "{ type: 'gainPrimary' }".to_string(),
        Ability::ChangeTertiary => "{ type: 'changeTertiary' }".to_string(),
    }
}

fn format_color(color: &Color) -> &'static str {
    match color {
        Color::Red => "Red",
        Color::Vermilion => "Vermilion",
        Color::Orange => "Orange",
        Color::Amber => "Amber",
        Color::Yellow => "Yellow",
        Color::Chartreuse => "Chartreuse",
        Color::Green => "Green",
        Color::Teal => "Teal",
        Color::Blue => "Blue",
        Color::Indigo => "Indigo",
        Color::Purple => "Purple",
        Color::Magenta => "Magenta",
    }
}

fn format_material_type(mt: &MaterialType) -> &'static str {
    match mt {
        MaterialType::Textiles => "Textiles",
        MaterialType::Ceramics => "Ceramics",
        MaterialType::Paintings => "Paintings",
    }
}

fn card_variant_name(card: &Card) -> String {
    serde_json::to_value(card)
        .unwrap()
        .as_str()
        .unwrap()
        .to_string()
}

fn buyer_variant_name(buyer: &BuyerCard) -> String {
    serde_json::to_value(buyer)
        .unwrap()
        .as_str()
        .unwrap()
        .to_string()
}

fn write_dye_card(out: &mut String, card: &Card) {
    let name = card.name();
    let pips = card.pips();
    let ability = card.ability();
    let colors_str: Vec<String> = pips.iter().map(|c| format!("'{}'", format_color(c))).collect();
    write!(
        out,
        "  {{\n    kind: 'dye',\n    name: '{}',\n    colors: [{}],\n    ability: {},\n  }},\n",
        name.replace('\'', "\\'"),
        colors_str.join(", "),
        format_ability(&ability),
    )
    .unwrap();
}

fn write_basic_dye_card(out: &mut String, card: &Card) {
    let name = card.name();
    let color = card.pips()[0];
    let ability = card.ability();
    write!(
        out,
        "  {{\n    kind: 'basicDye',\n    name: '{}',\n    color: '{}',\n    ability: {},\n  }},\n",
        name,
        format_color(&color),
        format_ability(&ability),
    )
    .unwrap();
}

fn write_material_card(out: &mut String, card: &Card) {
    let name = card.name();
    let ability = card.ability();
    let material_types = card.material_types();
    let pips = card.pips();

    let mt_str: Vec<String> = material_types
        .iter()
        .map(|mt| format!("'{}'", format_material_type(mt)))
        .collect();

    write!(out, "  {{\n    kind: 'material',\n    name: '{}',\n    materialTypes: [{}],\n", name.replace('\'', "\\'"), mt_str.join(", ")).unwrap();
    if !pips.is_empty() {
        write!(out, "    colorPip: '{}',\n", format_color(&pips[0])).unwrap();
    }
    write!(out, "    ability: {},\n  }},\n", format_ability(&ability)).unwrap();
}

fn write_action_card(out: &mut String, card: &Card) {
    let name = card.name();
    let ability = card.ability();
    let workshop_abilities = card.workshop_abilities();
    let wa_str: Vec<String> = workshop_abilities.iter().map(|a| format_ability(a)).collect();

    write!(
        out,
        "  {{\n    kind: 'action',\n    name: '{}',\n    ability: {},\n    workshopAbilities: [{}],\n  }},\n",
        name,
        format_ability(&ability),
        wa_str.join(", "),
    )
    .unwrap();
}

fn main() {
    println!("cargo:rerun-if-changed=../colori-core/src/types.rs");
    println!("cargo:rerun-if-changed=../colori-core/src/cards.rs");
    println!("cargo:rerun-if-changed=build.rs");

    let mut out = String::new();

    // Header
    out.push_str("// AUTO-GENERATED by colori-wasm/build.rs — do not edit by hand\n");
    out.push_str("import type { Card, BuyerCard, Color, AnyCardData, DyeCardData, BasicDyeCardData, MaterialCardData, ActionCardData, BuyerCardData } from './types';\n\n");

    // DYE_CARDS
    out.push_str("export const DYE_CARDS: DyeCardData[] = [\n");
    for card in dye_cards() {
        write_dye_card(&mut out, &card);
    }
    out.push_str("];\n\n");

    // MATERIAL_CARDS (starter materials)
    out.push_str("export const MATERIAL_CARDS: MaterialCardData[] = [\n");
    for card in starter_material_cards() {
        write_material_card(&mut out, &card);
    }
    out.push_str("];\n\n");

    // DRAFT_MATERIAL_CARDS
    out.push_str("export const DRAFT_MATERIAL_CARDS: MaterialCardData[] = [\n");
    for card in draft_material_cards() {
        write_material_card(&mut out, &card);
    }
    out.push_str("];\n\n");

    // BASIC_DYE_CARDS
    out.push_str("export const BASIC_DYE_CARDS: BasicDyeCardData[] = [\n");
    for card in basic_dye_cards() {
        write_basic_dye_card(&mut out, &card);
    }
    out.push_str("];\n\n");

    // ACTION_CARDS
    out.push_str("export const ACTION_CARDS: ActionCardData[] = [\n");
    for card in action_cards() {
        write_action_card(&mut out, &card);
    }
    out.push_str("];\n\n");

    // PRIMARIES, SECONDARIES, TERTIARIES — derived from dye card pips
    let dyes = dye_cards();
    let mut primaries: Vec<&'static str> = Vec::new();
    let mut secondaries: Vec<&'static str> = Vec::new();
    let mut tertiaries: Vec<&'static str> = Vec::new();

    for card in &dyes {
        let pips = card.pips();
        if pips.len() == 3 {
            // Primary dye (pure or 2+1) — collect unique primary colors
            let color_name = format_color(&pips[0]);
            if !primaries.contains(&color_name) {
                primaries.push(color_name);
            }
        } else if pips.len() == 2 {
            // Secondary dye — first pip is the secondary color
            let color_name = format_color(&pips[0]);
            if !secondaries.contains(&color_name) {
                secondaries.push(color_name);
            }
        } else if pips.len() == 1 {
            // Tertiary dye — single pip is the tertiary color
            let color_name = format_color(&pips[0]);
            if !tertiaries.contains(&color_name) {
                tertiaries.push(color_name);
            }
        }
    }

    write!(
        out,
        "export const PRIMARIES: Color[] = [{}];\n",
        primaries
            .iter()
            .map(|c| format!("'{}'", c))
            .collect::<Vec<_>>()
            .join(", ")
    )
    .unwrap();
    write!(
        out,
        "export const SECONDARIES: Color[] = [{}];\n",
        secondaries
            .iter()
            .map(|c| format!("'{}'", c))
            .collect::<Vec<_>>()
            .join(", ")
    )
    .unwrap();
    write!(
        out,
        "export const TERTIARIES: Color[] = [{}];\n\n",
        tertiaries
            .iter()
            .map(|c| format!("'{}'", c))
            .collect::<Vec<_>>()
            .join(", ")
    )
    .unwrap();

    // ARGOL_CARD
    let argol = argol_card();
    out.push_str("export const ARGOL_CARD: ActionCardData = {\n");
    write!(
        out,
        "  kind: 'action',\n  name: '{}',\n  ability: {},\n  workshopAbilities: [{}],\n",
        argol.name(),
        format_ability(&argol.ability()),
        argol
            .workshop_abilities()
            .iter()
            .map(|a| format_ability(a))
            .collect::<Vec<_>>()
            .join(", "),
    )
    .unwrap();
    out.push_str("};\n\n");

    // BUYER_CARDS — generated from generate_all_buyers
    let all_buyers = generate_all_buyers();
    out.push_str("export const BUYER_CARDS: BuyerCardData[] = [\n");
    for buyer in &all_buyers {
        let colors: Vec<String> = buyer
            .color_cost()
            .iter()
            .map(|c| format!("'{}'", format_color(c)))
            .collect();
        write!(
            out,
            "  {{ kind: 'buyer', stars: {}, requiredMaterial: '{}', colorCost: [{}] }},\n",
            buyer.stars(),
            format_material_type(&buyer.required_material()),
            colors.join(", "),
        )
        .unwrap();
    }
    out.push_str("];\n\n");

    // CARD_LOOKUP
    out.push_str("const CARD_LOOKUP: Record<string, AnyCardData> = {};\n\n");

    // Register basic dyes
    for card in basic_dye_cards() {
        let variant = card_variant_name(&card);
        write!(
            out,
            "CARD_LOOKUP['{}'] = {{ kind: 'basicDye', name: '{}', color: '{}', ability: {} }};\n",
            variant,
            card.name(),
            format_color(&card.pips()[0]),
            format_ability(&card.ability()),
        )
        .unwrap();
    }
    out.push('\n');

    // Register dye cards
    for (i, card) in dye_cards().iter().enumerate() {
        let variant = card_variant_name(card);
        write!(out, "CARD_LOOKUP['{}'] = DYE_CARDS[{}];\n", variant, i).unwrap();
    }
    out.push('\n');

    // Register starter materials
    for (i, card) in starter_material_cards().iter().enumerate() {
        let variant = card_variant_name(card);
        write!(out, "CARD_LOOKUP['{}'] = MATERIAL_CARDS[{}];\n", variant, i).unwrap();
    }
    out.push('\n');

    // Register draft materials
    for (i, card) in draft_material_cards().iter().enumerate() {
        let variant = card_variant_name(card);
        write!(
            out,
            "CARD_LOOKUP['{}'] = DRAFT_MATERIAL_CARDS[{}];\n",
            variant, i
        )
        .unwrap();
    }
    out.push('\n');

    // Register action cards
    for (i, card) in action_cards().iter().enumerate() {
        let variant = card_variant_name(card);
        write!(out, "CARD_LOOKUP['{}'] = ACTION_CARDS[{}];\n", variant, i).unwrap();
    }
    out.push_str("CARD_LOOKUP['Argol'] = ARGOL_CARD;\n\n");

    // BUYER_LOOKUP
    out.push_str("const BUYER_LOOKUP: Record<string, BuyerCardData> = {};\n");
    for (i, buyer) in all_buyers.iter().enumerate() {
        let variant = buyer_variant_name(buyer);
        write!(
            out,
            "BUYER_LOOKUP['{}'] = BUYER_CARDS[{}];\n",
            variant, i
        )
        .unwrap();
    }
    out.push('\n');

    // Lookup functions
    out.push_str("export function getCardData(card: Card): AnyCardData {\n  return CARD_LOOKUP[card];\n}\n\n");
    out.push_str("export function getBuyerData(buyer: BuyerCard): BuyerCardData {\n  return BUYER_LOOKUP[buyer];\n}\n\n");
    out.push_str("export function getAnyCardData(card: string): AnyCardData {\n  return CARD_LOOKUP[card] ?? BUYER_LOOKUP[card];\n}\n\n");

    // getCardPips
    out.push_str(
        "export function getCardPips(card: string): Color[] {\n\
         \x20 const data = getAnyCardData(card);\n\
         \x20 if (!data) return [];\n\
         \x20 switch (data.kind) {\n\
         \x20   case 'dye': return data.colors;\n\
         \x20   case 'basicDye': return [data.color];\n\
         \x20   case 'material': return data.colorPip ? [data.colorPip] : [];\n\
         \x20   case 'action': return [];\n\
         \x20   case 'buyer': return [];\n\
         \x20 }\n\
         }\n\n",
    );

    // DRAFT_COPY_COUNTS
    out.push_str("export const DRAFT_COPY_COUNTS: Record<string, number> = {};\n");
    for card in dye_cards() {
        write!(
            out,
            "DRAFT_COPY_COUNTS['{}'] = {};\n",
            card.name().replace('\'', "\\'"),
            DYE_COPIES,
        )
        .unwrap();
    }
    for card in draft_material_cards() {
        write!(
            out,
            "DRAFT_COPY_COUNTS['{}'] = {};\n",
            card.name().replace('\'', "\\'"),
            MATERIAL_COPIES,
        )
        .unwrap();
    }
    for card in action_cards() {
        write!(
            out,
            "DRAFT_COPY_COUNTS['{}'] = {};\n",
            card.name().replace('\'', "\\'"),
            ACTION_COPIES,
        )
        .unwrap();
    }
    out.push('\n');

    // getDraftCopies
    out.push_str("export function getDraftCopies(name: string): number {\n  return DRAFT_COPY_COUNTS[name] ?? 1;\n}\n\n");

    // CardCategory interface
    out.push_str("export interface CardCategory {\n  label: string;\n  cardNames: string[];\n  totalCopies: number;\n}\n\n");

    // DRAFT_CARD_CATEGORIES
    // Build categories from the dye card data
    let mut pure_primary_dye_names: Vec<String> = Vec::new();
    let mut primary_dye_names: Vec<String> = Vec::new();
    let mut secondary_dye_names: Vec<String> = Vec::new();
    let mut tertiary_dye_names: Vec<String> = Vec::new();

    for card in dye_cards() {
        let name = card.name().replace('\'', "\\'");
        let pips = card.pips();
        if pips.len() == 3 && pips[0] == pips[1] && pips[1] == pips[2] {
            // 3 identical primary pips = pure primary dye
            pure_primary_dye_names.push(name.to_string());
        } else if pips.len() == 3 {
            // 3 pips, not all same = primary dye (2+1)
            primary_dye_names.push(name.to_string());
        } else if pips.len() == 2 {
            // 2 pips = secondary dye
            secondary_dye_names.push(name.to_string());
        } else if pips.len() == 1 {
            // 1 pip = tertiary dye
            tertiary_dye_names.push(name.to_string());
        }
    }

    let action_names: Vec<String> = action_cards()
        .iter()
        .map(|c| c.name().to_string())
        .collect();

    let mut double_material_names: Vec<String> = Vec::new();
    let mut material_color_names: Vec<String> = Vec::new();
    let mut dual_material_names: Vec<String> = Vec::new();

    for card in draft_material_cards() {
        let mt = card.material_types();
        let pips = card.pips();
        let name = card.name().replace('\'', "\\'");
        if mt.len() == 2 && mt[0] == mt[1] && pips.is_empty() {
            double_material_names.push(name.to_string());
        } else if !pips.is_empty() {
            material_color_names.push(name.to_string());
        } else if mt.len() == 2 && mt[0] != mt[1] && pips.is_empty() {
            dual_material_names.push(name.to_string());
        }
    }

    fn format_category(out: &mut String, label: &str, names: &[String], copies_per: usize) {
        let names_str: String = names
            .iter()
            .map(|n| format!("'{}'", n))
            .collect::<Vec<_>>()
            .join(", ");
        write!(
            out,
            "  {{ label: '{}', cardNames: [{}], totalCopies: {} }},\n",
            label,
            names_str,
            names.len() * copies_per,
        )
        .unwrap();
    }

    out.push_str("export const DRAFT_CARD_CATEGORIES: CardCategory[] = [\n");
    format_category(&mut out, "Pure Primary Dyes", &pure_primary_dye_names, DYE_COPIES);
    format_category(&mut out, "Primary Dyes", &primary_dye_names, DYE_COPIES);
    format_category(&mut out, "Secondary Dyes", &secondary_dye_names, DYE_COPIES);
    format_category(&mut out, "Tertiary Dyes", &tertiary_dye_names, DYE_COPIES);
    format_category(&mut out, "Action Cards", &action_names, ACTION_COPIES);
    format_category(&mut out, "Double Materials", &double_material_names, MATERIAL_COPIES);
    format_category(&mut out, "Material + Color", &material_color_names, MATERIAL_COPIES);
    format_category(&mut out, "Dual Materials", &dual_material_names, MATERIAL_COPIES);
    out.push_str("];\n\n");

    // getStarterCardCategories
    let starter_dye_names: Vec<String> = basic_dye_cards()
        .iter()
        .map(|c| format!("'{}'", c.name()))
        .collect();
    let starter_mat_names: Vec<String> = starter_material_cards()
        .iter()
        .map(|c| format!("'{}'", c.name()))
        .collect();

    out.push_str("export function getStarterCardCategories(numPlayers: number): CardCategory[] {\n");
    write!(
        out,
        "  const starterDyeNames = [{}];\n",
        starter_dye_names.join(", ")
    )
    .unwrap();
    write!(
        out,
        "  const starterMaterialNames = [{}];\n",
        starter_mat_names.join(", ")
    )
    .unwrap();
    out.push_str("  return [\n");
    out.push_str("    { label: 'Starter Dyes', cardNames: starterDyeNames, totalCopies: starterDyeNames.length * numPlayers },\n");
    out.push_str("    { label: 'Starter Materials', cardNames: starterMaterialNames, totalCopies: starterMaterialNames.length * numPlayers },\n");
    out.push_str("    { label: 'Argol', cardNames: ['Argol'], totalCopies: 1 * numPlayers },\n");
    out.push_str("  ];\n");
    out.push_str("}\n");

    // Write the file
    let out_path = std::path::Path::new("..").join("src").join("data").join("cards.ts");
    let mut file = std::fs::File::create(&out_path).expect("failed to create cards.ts");
    file.write_all(out.as_bytes())
        .expect("failed to write cards.ts");
}
